---
Title: ' Rubyで関数型プログラミング'
Date: 2011-08-19T22:13:20+09:00
URL: http://tarao.hatenablog.com/entry/20110819/1313759600
EditURL: https://blog.hatena.ne.jp/tarao/tarao.hatenablog.com/atom/entry/6653586347149236147
---

Rubyでの快適関数型プログラミングライフを追求するあまり, 使えるのか使えないのかよくわからないものを作ってしまったという話. Rubyに不慣れな人や関数型プログラミングに不慣れな人に対して酷なのはまだわかるとしても, C++(というかboostでの関数型プログラミング)に不慣れな人も全力で置いてきぼりにする誰得記事になってしまった......

=====
** 経緯

そもそもRubyはだいぶLispっぽくて, ブロックとイテレータを使うだけで関数型プログラミングになってしまう. たとえばこんな感じで:
>|ruby|
%w|1 2 3 4 5|.map{|x| x.to_i}
||<
<code>%w|1 2 3 4 5|</code>は<code>'1'</code>から<code>'5'</code>までの文字列からなる配列で, その配列のメソッド<code>Array#map</code>((本当は<code>Array</code> < <code>Enumerable#map</code>.))に対して, 受け取った引数を整数化するブロックを渡してやると, <code>1</code>から<code>5</code>までの整数からなる配列が得られる. たとえば関数型プログラミング言語として名高い(?)OCamlで書くなら
>|ocaml|
List.map (fun x -> int_of_string x) [ "1"; "2"; "3"; "4"; "5" ]
||<
という感じ. メソッド名やクロージャの作り方や引数の順序などの記法上の差異を除けばよく似ている. 実に関数型っぽい.

最初から関数型っぽさの漂うRubyに対して少し文句があるとすれば, せっかくオブジェクト指向でもあるのに, いちいち<code>x</code>を用意しておいて<code>x</code>に対して<code>to_i</code>を呼ぶのがいけてないということくらいだろうか. 配列の各要素に対して<code>to_i</code>しろって言ったらレシーバはその要素に決まってんだろ空気読め, みたいな.

と思いきや, これは実は最初からできる.
>|ruby|
%w|1 2 3 4 5|.map(&:to_i)
||<
と書くと期待通り動く((どうしてこれでうまくいくのか気になる人はこの辺を読もう: [http://blog.livedoor.jp/sasata299/archives/51541958.html:title] )). なにこれべんり.

ただこれでもまだ不満があって,
>|ruby|
%w|1 2 3 4 5|.map{|x| x.to_i * 10}
||<
みたいなのを簡単に書けない. べつに<code>to_i</code>が悪いわけではなくて,
>|ruby|
[1, 2, 3, 4, 5].map{|x| x * 10}
||<
だったとしても簡単に書けない.
>|ruby|
[1, 2, 3, 4, 5].map(&:*)
||<
というのは構文として正しいし, きちんと<code>*</code>メソッドの呼び出しを<code>Proc</code>化してくれるけれど, <code>10</code>を渡すことができていない. C++での関数型プログラミングに慣れている人ならば思うことだろう, [http://www.boost.org/doc/libs/release/libs/bind:title=boost::bind]が欲しい, と. 欲しければ作ってしまおう. さらに欲張って[http://www.boost.org/doc/libs/release/libs/lambda:title=boost::lambda]相当のものを作ってしまおう.

** できたものと基本的な使い方

:できたもの:https://github.com/tarao/ruby-functional

>|ruby|
require 'functional/lambda'

Lambda.eval do
  [1, 2, 3, 4, 5].map(& _1 * 10)
end
||<

*** ブロックで囲むのめんどくさい

>|ruby|
include Lambda::Primitive
include Lambda::Variable
include Lambda::Statement
||<
としておくと, <code>Lambda.eval do ... end</code>で囲まなくても<code>_1</code>等が使えるようになる. この後の例では<code>Lambda.eval do</code>, <code>end</code>は省略.

*** <code>_1</code>って書くのすらだるい

<code>_</code>と書いても<code>_1</code>の意味になるようにしてあるので, 引数が1つしかないなら<code>1</code>は書かない方が見やすいかも. ただし, <code>_</code>が既に定義されていると使えない(irbなんかでは定義されてしまっているっぽいので使えない).

** 具体例

>|ruby|
%w|1 2 3 4 5|.map(& _1.to_i * 10)
# => [10, 20, 30, 40, 50]
||<
<code>map</code>によって各要素が<code>_1</code>の部分に渡ってくる.

>|ruby|
[1, 2, 3, 4, 5].map(& _1 * _1)
# => [1, 4, 9, 16, 25]
||<
2乗を計算.

>|ruby|
(_3 - _2 * _1).call(10, 20, 30)
(_3 - _2 * _1)[10, 20, 30]
# => -170
||<
<code>30 - 20 * 10</code>を計算. <code>(_3 - _2 * _1)</code>の部分は<code>Proc</code>なので<code>[]</code>でも呼び出せる.

** 制限

実際の実装は以下のような方針.
- まず<code>bind</code>を定義
- <code>_1.method(*args)</code>は, <strong><code>_1</code>の<code>method_missing</code>の中で</strong><code>:method.to_proc.bind(_1, *args)</code>に変換
このことからすぐにわかるように, メソッドのレシーバが<code>_1</code>等, このライブラリで管理しているオブジェクトでないと, <code>bind</code>が呼ばれない.

たとえば
>|ruby|
[1, 2, 3, 4, 5].map(& 10 * _1)
||<
は動かない!

こういうときのために, いちおう代替的な記法があって,
>|ruby|
[1, 2, 3, 4, 5].map(& :*.to_proc.bind(10, _1))
||<
とすればいける. ただいくらなんでもこれは長すぎるので,
>|ruby|
Lambda::Syntax::Method.from_symbol[] # 記法を有効にするおまじない
[1, 2, 3, 4, 5].map(& :*[10, _1])
||<
と書けるようにしてある.

** 高度な使い方 - 高階関数

関数型と言うからには高階関数も使いたい. 関数を返す関数も書きたい. つまりラムダ計算で言うところの
>||
λx.λy.λz.z-y*x
||<
みたいなのが書きたい. 「<code>_1</code>とか<code>_2</code>ってde Bruijn indexなんでしょ, 簡単じゃん!」と勘違いしそうだけど, <code>_1</code>は(1階の)多引数関数の1番目の引数という意味なのでde Bruijn indexではない. だから
>|ruby|
(_3 - _2 * _1)[10][20][30]
||<
と書いてもうまくいかない.

関数を返す関数をサポートするにあたっては, boost::lambdaに倣って<code>protect</code>という関数を用意した.
>|ruby|
(protect(protect(_1)) - protect(_1) * _1)[10][20][30]
# => -170
||<
関数が呼び出されたときに<code>protect</code>された変数には代入されない代わりに<code>protect</code>が1回剥れる. 平たく言うと段階計算みたいなことが起きる.
>|ruby|
(protect(protect(_1)) - protect(_1) * _1)[10][20][30]
# -> (protect(_1) - _1 * 10)[20][30]
# -> (_1 - 20 * 10)[30]
# -> (30 - 20 * 10)
# -> -170
||<

ただ, 厄介なことに, この段階計算の途中でメソッドのレシーバがふつうのオブジェクトになってしまうと, 制限のところで説明したのと同じ問題が発生してうまくいかない.
>|ruby|
(_1 - protect(_1))[10][20]
# -> (10 - _1)[20]
# -> TypeError!
||<
で, ふつうだったら<code>-</code>のところを<code>:-[...]</code>に変えればいいけれど, いまは段階計算しているのでそれでもうまくいかない.
>|ruby|
:-[_1, protect(_1)][10][20]
# -> (_1 - protect(_1))[10][20]
# -> (10 - _1)[20]
# -> TypeError!
||<
計算の段階が1つ進んだ後で<code>:-[...]</code>をしないといけない. ということは, <code>:-</code>に対して<code>[...]</code>を呼ぶところを<code>protect</code>しないといけない.
>|ruby|
:send[protect(:-), :[], _1, protect(_1)][10][20]
# -> :-.send(:[], 10, _1)[20]
# -> :-[10, _1][20]
# -> 10 - 20
# -> -10
||<
うん, これは, なんだ, キモい. なによりも, 問題の在処がわかった瞬間にこれをすらすら書いてしまった自分が恐しい.

こんな面倒な段階計算スキルを身につけなくても, 1引数の高階関数しか使わないなら((もう少し正確に言うと「1引数でかつ関数全体のλ抽象が左に寄っているもの」である必要があり, なんでもこの方法でいけるわけではない.)), 多引数関数をカリー化((Ruby 1.9.2からは<code>Proc#curry</code>が標準で定義されている. 今回はRuby 1.8でも使えるように独自にも実装した.))してしまえばいい.
>|ruby|
(_3 - _2 * _1).curry[10][20][30]
# => -170
(_1 - _2).curry[10][20]
# => -10
||<
これはカンタン. わかりやすい!

** その他書き切れなかったこと

- <code>if_</code>, <code>else_</code>等も用意した
- <code>bind</code>が返す<code>Proc</code>にはブロックも渡せる(Ruby 1.9以降)
- 高階関数で関数を引数にとる場合

** まとめ

- Rubyはもともと関数型っぽい
- 関数型プログラミングを満喫するためにboost::lambda相当のものをRubyで実装
- 欠点
-- レシーバがふつうのオブジェクトだとうまくいかない
-- 高階関数めんどくさい
- 欠点を補う手段
-- <code>:symbol[...]</code>記法
-- <code>Proc#curry</code>使え

** 追記

*** 2011-08-20T02:29+0000 ブックマークコメントへの返信
<blockquote>これを関数型と言われるとなんか違う気がする</blockquote>
「関数型言語」と「関数型プログラミング」を混同しているために生じる違和感ではないでしょうか. 文中の「関数型プログラミング」「関数型」が指しているのはプログラミングのパラダイムとしての関数型であって, とくにfirst-classな関数とimmutableなデータを使うプログラミング技法を指しています.
