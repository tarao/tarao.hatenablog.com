---
Title: Docker Quizを力技で解く
Category:
- golang
Date: 2020-09-09T18:48:27+09:00
URL: https://tarao.hatenablog.com/entry/2020/09/09/docker-quiz
EditURL: https://blog.hatena.ne.jp/tarao/tarao.hatenablog.com/atom/entry/26006613625771443
---

こういうのがあった:

[https://twitter.com/hatenatech/status/1302845698732249089:embed]

自社のインターンの課題だけど, 僕は今年のインターンには全く関わっていないので, 新鮮な気持ちで問題を楽しめた.  みんな話題にしているのはQ7でなかなか骨がある.  全体的にCTFっぽさがある(参加したことないのでしらんけど)中で, Q7はとくにそっち方向の面白さがある.

>>
Q7 このイメージのentrypointとして指定されているコマンドのソースコードを復元して、この問題の答えを取得せよ
<<

「ソースコードを復元して」と言われて「うーん, それホントに復元しないとダメかな?」と考えていたら「ワシも若い頃はバイナリ畑を守るバイナリアンとして村のために戦ったもんじゃ」みたいな気持ちが急激に湧いてきて, 復元せずに解いてやろう, となった.

ちなみに, 実際は途中で諦めて普通にソースコードを復元して解いてしまったので, ここに書くのは「後にして思えばこうやってたら解けてたな」というやつです.  後出しジャンケンです.  あと想定された解き方と違うとはいえ, 読めばQ7の答えがわかってしまうので自分で挑戦したい人は<strong>挑戦した後で読むことをオススメ</strong>します.

====
** 逆アセンブル

バイナリアンだとか威勢のいいことを言ったけど, 10年以上前に勉強のために実行ファイルをクラックする練習をちょっとやったことがある程度で, そのときもOllyDbgとか使っていた.  アセンブリコードくらいにはなっていてもらわないと手も足も出ない.

今回の実行ファイル<code>docker_quiz</code>はどうやらGoで書かれていそうで, そうなると<code>go tool objdump</code>で逆アセンブルできる.  <code>-S</code>というオプションもあったけど, そこまで役に立つ情報がたくさん出る感じではなかった.  Goのツールでなくてもそこら辺の逆アセンブラを使ってもそこまで大差なさそう.

** 答え合わせしている箇所を特定

まず最初の方を見ると<code>/usr/local/go/src/internal/cpu/cpu.go</code>とか言っていて, これはきっとGoのランタイムの内部コードだろう.  静的リンクなのでそういうのもついてくる.  逆に一番下を見ると<code>/app/docker_quiz.go</code>の<code>main.main</code>と言っていて, これがアプリケーションコードっぽい.

アセンブリコードの読み方もだいぶ忘れているし, 以前読んだことがあるのはCかC++からコンパイルされたもので, Goでコンパイルしたときの様子がどういう感じか全く知らないので, ガチで一字一句読むのはなるべく避けたい.

<code>main.main</code>をざっくり眺めると<code>CALL main.printQuestions(SB)</code>というのが目につく.  きっとこれが問題を出力しているところだろう.  さらに見ていくと<code>CALL main.verify(SB)</code>というのがある.  見るからに答え合わせしているところっぽい!  この関数の中身に絞って見ていけばよさそうだ.

<code>main.verify</code>はそこそこの長さだけど, 特徴的なところとして<code>crypto/sha512</code>を使っている.  どうやら答え合わせはSHA-512のハッシュ値で照合してそうだ.

>|asm|
docker_quiz.go:96   0x4b0b0f    e82c91fdff    CALL crypto/sha512.(*digest).Sum(SB)
||<

確かに, (問題文に書いてあるQ1やコマンドで出力されるQ2は別として)Q3~Q6の答えはバイナリファイルを<code>strings</code>しても登場しないのだ.  しかし, Q7の答えもSHA-512で照合してるのだとすると, たとえソースコードを復元しても答えがわからないのではないか?  それともイマドキは短めの文字列ならブルートフォースでも割と現実的なのだろうか?

<code>main.verify</code>をもう少し観察してみると, SHA-512を使っている辺りは後ろの方で, ここにやってくるのは条件分岐で飛んできたときだけのようだ.

>|asm|
docker_quiz.go:92   0x4b0975    4883fe03      CMPQ $0x3, SI
docker_quiz.go:92   0x4b0979    0f85ea000000  JNE 0x4b0a69
||<

<code>SI</code>が<code>3</code>じゃなかったときだけSHA-512で照合していそう.  では逆に<code>3</code>だったときはどうなるのか.  メモリ操作をしたりスライスを作ったりしているのを無視していくと, あった, これや!!

>|asm|
docker_quiz.go:106  0x4b09f2    83f3ff        XORL $-0x1, BX
||<

<code>-1</code>とXORをとっている.  <code>-1</code>というより<code>0xFF</code>とXORを取ると言った方がわかりやすいか.  つまりQ7だけSHA-512ではなく<code>0xFF</code>とXORした値(ビット反転した値)で照合しているのではないか?

** 答えを特定

Q6までの答えは<code>FLAG_<var>xxxxxxxx</var></code>というものが多く, Q7の答えもおそらくこの形式だろう.  そうすると<code>FLAG_</code>の文字列をビット反転した<code>b9b3beb8a0</code>(16進)で始まるバイト列が実行ファイルの中に書かれているはずで, ここからさらに8バイト読めば照合先の値がわかるはず.  バイナリエディタで検索すると, それっぽい箇所がある.  ビンゴ!

>|
00188510: 0100 0000 0000 0000 <span style="background-color: #003399"><span style="background-color: #6699ff">b9b3 beb8 a0</span>ce c98a</span>  ................
00188520: <span style="background-color: #003399">ca95 889d 8d</span>00 0000 2f64 6576 2f75 7261  ......../dev/ura
|<

あとはこれをビット反転して文字列化すればQ7の答えが得られる.

** 実際にはどうだったか

SHA-512で照合してそうだよね, までは上に書いたのと全く同じ流れ.

ただ「それともイマドキは短めの文字列ならブルートフォースでも割と現実的なのだろうか?」と思ったので, 時間かかるだろうからひとまずブルートフォースするコードは書いて走らせておいた. まずQ6までのSHA-512値が書いてある場所をバイナリエディタで探して, Q7のSHA-512値が書いてあるとしたらここ, というバイト列に対してブルートフォースする.  <code>FLAG_<var>xxxxxxxx</var></code>の<code><var>x</var></code>には半角小文字英数字が入りそうで, [tex:36^8]なので3兆通りくらいある.  ちなみにシングルスレッドで手元のマシンで走らせた感じだと意外とどんどん進んで, 1ヶ月くらいあれば普通に終わってそうだった.  実際にはSHA-512ではないのでぜんぶ外れる運命だけどね......

走らせてる間にSHA-512じゃない分岐の辺りを読んでみたけど, よくわからなかった.  SHA-512じゃないとしたらXORとか足したり引いたりとかだろうなぁ, と思ってXORを見てもなんか関係なさそうなXORがちょいちょい出てきてよくわからん.  そもそもここは<code>3</code>で分岐しててこれはQ3だけチェック方法が違うのでは? (とそのときは思ったけどもしそういう感じならQ4だろう.) うーん, わからん.  かといってアセンブリコードをつぶさに読んでいくの, やりたくない.  もういいや正攻法で解くか.  という感じで諦めてしまっていた.

<code>-1</code>とXORしてるのは目に入っていたけど<code>-1</code>がマジックナンバー感なくて目が滑ってしまっていた.  悔しい!
